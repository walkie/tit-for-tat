use num::Num;
use std::cmp::Ordering;
use std::collections::HashMap;
use std::fmt::Debug;
use std::hash::Hash;

use crate::core::{Payoff, PlayerIndex, Profile, ProfileIter};

/// A lookup table of payoffs indexed by one move played by each player in the game.
///
/// Payoff tables are used for normal-form game representations.
pub struct PayoffTable<Move: Copy, MoveIter: Iterator<Item = Move> + Clone, Util, const N: usize> {
    profile_iter: ProfileIter<Move, MoveIter, N>,
    payoff_map: HashMap<Profile<Move, N>, Payoff<Util, N>>,
}

impl<Move, MoveIter, Util, const N: usize> PayoffTable<Move, MoveIter, Util, N>
where
    Move: Copy + Debug + Eq + Hash,
    MoveIter: Iterator<Item = Move> + Clone,
    Util: Copy + Debug + Num + Ord,
{
    /// Construct a payoff table given a profile iterator and a vector of payoffs.
    ///
    /// The payoff vector is expected to contain one payoff per profile in the order that the
    /// profiles are generated by the iterator, which corresponds to
    /// [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
    ///
    /// # Errors
    /// - If *too few* payoffs are provided, logs an error and returns `None`.
    /// - If *too many* payoffs are provided, logs a warning and returns a table in which the
    ///   excess payoffs are ignored.
    pub fn from_vec(
        profile_iter: ProfileIter<Move, MoveIter, N>,
        payoffs: Vec<Payoff<Util, N>>,
    ) -> Option<Self> {
        let num_profiles = profile_iter.clone().count();
        let num_payoffs = payoffs.len();
        match num_profiles.cmp(&num_payoffs) {
            Ordering::Greater => {
                log::error!(
                    "PayoffTable::from_vec(): not enough payoffs provided; expected {}, got {}",
                    num_profiles,
                    num_payoffs,
                );
                return None;
            }
            Ordering::Less => {
                log::warn!(
                    "PayoffTable::from_vec(): too many payoffs provided; expected {}, got {}",
                    num_profiles,
                    num_payoffs,
                );
            }
            Ordering::Equal => {}
        }

        let mut payoff_map = HashMap::with_capacity(num_profiles);
        for (profile, payoff) in profile_iter.clone().zip(payoffs) {
            payoff_map.insert(profile, payoff);
        }
        Some(PayoffTable {
            profile_iter,
            payoff_map,
        })
    }

    /// Construct a payoff table given a profile iterator and a function that returns the payoff
    /// for each profile.
    ///
    /// # Errors
    /// If the payoff function returns `None` for a generated profile, logs an error and return
    /// `None`.
    pub fn from_fn(
        profile_iter: ProfileIter<Move, MoveIter, N>,
        payoff_fn: impl Fn(Profile<Move, N>) -> Option<Payoff<Util, N>> + 'static,
    ) -> Option<Self> {
        let num_profiles = profile_iter.clone().count();

        let mut payoff_map = HashMap::with_capacity(num_profiles);
        for profile in profile_iter.clone() {
            if let Some(payoff) = payoff_fn(profile) {
                payoff_map.insert(profile, payoff);
            } else {
                log::error!(
                    "PayoffTable::from_fn(): payoff function returned `None` for profile {:?}",
                    profile,
                );
                return None;
            }
        }
        Some(PayoffTable {
            profile_iter,
            payoff_map,
        })
    }

    /// Get the payoff associated with a given strategy profile.
    ///
    /// # Errors
    /// Returns `None` if the profile is not in the payoff table.
    pub fn payoff(&self, profile: Profile<Move, N>) -> Option<Payoff<Util, N>> {
        self.payoff_map.get(&profile).copied()
    }

    /// Get an iterator over the profiles in the payoff table.
    ///
    /// The profiles are effectively the addresses of cells in the table. They are enumerated in
    /// [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
    pub fn profile_iter(&self) -> ProfileIter<Move, MoveIter, N> {
        self.profile_iter.clone()
    }

    /// Get an iterator over the cells in the payoff table.
    ///
    /// Each cell consists of the profile that addresses that cell, and the payoff that is its
    /// value. The cells are enumerated in
    /// [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
    pub fn cell_iter(&self) -> TableCellIter<Move, MoveIter, Util, N> {
        TableCellIter {
            profile_iter: self.profile_iter.clone(),
            payoff_map: &self.payoff_map,
        }
    }
}

/// A cell in a payoff table, consisting of a profile and a payoff.
///
/// The profile is the address of the cell within the table while the payoff is its value.
pub struct TableCell<Move, Util, const N: usize> {
    pub profile: Profile<Move, N>,
    pub payoff: Payoff<Util, N>,
}

/// An iterator over all of the cells in a payoff table, enumerated in
/// [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order).
pub struct TableCellIter<
    'table,
    Move: Copy,
    MoveIter: Iterator<Item = Move> + Clone,
    Util,
    const N: usize,
> {
    profile_iter: ProfileIter<Move, MoveIter, N>,
    payoff_map: &'table HashMap<Profile<Move, N>, Payoff<Util, N>>,
}

impl<'table, Move, MoveIter, Util, const N: usize> TableCellIter<'table, Move, MoveIter, Util, N>
where
    Move: Copy + Debug + Eq + Hash,
    MoveIter: Iterator<Item = Move> + Clone,
    Util: Copy + Debug + Num + Ord,
{
    /// Constrain the iterator to enumerate only those cells where the given player plays a
    /// specific move.
    ///
    /// If the move is not a valid move for that player, then the resulting iterator will not
    /// generate any profiles.
    ///
    /// Multiple invocations of [`include()`](TableCellIter::include) and
    /// [`exclude()`](TableCellIter::exclude) can be chained together to add several constraints to
    /// the iterator.
    ///
    /// See the documentation for [`ProfileIter::include()`](crate::core::ProfileIter::include) for
    /// examples and more info.
    pub fn include(self, player: PlayerIndex<N>, the_move: Move) -> Self {
        TableCellIter {
            profile_iter: self.profile_iter.include(player, the_move),
            ..self
        }
    }

    /// Constrain the iterator to enumerate only those cells where the given player *does not* play
    /// a specific move.
    ///
    /// If the move is not a valid move for that player, then this method will have no effect.
    ///
    /// Multiple invocations of [`include()`](TableCellIter::include) and
    /// [`exclude()`](TableCellIter::exclude) can be chained together to add several constraints to
    /// the iterator.
    ///
    /// See the documentation for [`ProfileIter::exclude()`](crate::core::ProfileIter::exclude) for
    /// examples and more info.
    pub fn exclude(self, player: PlayerIndex<N>, the_move: Move) -> Self {
        TableCellIter {
            profile_iter: self.profile_iter.exclude(player, the_move),
            ..self
        }
    }

    /// Constrain the iterator to generate only cells that correspond to "adjacent" profiles of the
    /// given profile for a given player.
    ///
    /// An adjacent profile is one where the given player plays a different move, but all other
    /// players play the move specified in the profile.
    ///
    /// Note that this doesn't correspond to adjacency in the payoff table, but rather an entire
    /// row or column, minus the provided profile.
    ///
    /// See the documentation for [`ProfileIter::adjacent()`](crate::core::ProfileIter::adjacent)
    /// for examples and more info.
    pub fn adjacent(self, player: PlayerIndex<N>, profile: Profile<Move, N>) -> Self {
        TableCellIter {
            profile_iter: self.profile_iter.adjacent(player, profile),
            ..self
        }
    }
}

impl<'table, Move, MoveIter, Util, const N: usize> Iterator
    for TableCellIter<'table, Move, MoveIter, Util, N>
where
    Move: Copy + Debug + Eq + Hash,
    MoveIter: Iterator<Item = Move> + Clone,
    Util: Copy + Debug + Num + Ord,
{
    type Item = TableCell<Move, Util, N>;
    fn next(&mut self) -> Option<Self::Item> {
        self.profile_iter.next().map(|profile| TableCell {
            profile,
            payoff: *self.payoff_map.get(&profile).unwrap(),
        })
    }
}

impl<'table, Move, MoveIter, Util, const N: usize> IntoIterator
    for &'table PayoffTable<Move, MoveIter, Util, N>
where
    Move: Copy + Debug + Eq + Hash,
    MoveIter: Iterator<Item = Move> + Clone,
    Util: Copy + Debug + Num + Ord,
{
    type Item = TableCell<Move, Util, N>;
    type IntoIter = TableCellIter<'table, Move, MoveIter, Util, N>;
    fn into_iter(self) -> Self::IntoIter {
        self.cell_iter()
    }
}
